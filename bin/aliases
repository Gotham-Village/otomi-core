. .env/cloud

alias d="docker"
alias aw="aws"
alias gc="gcloud"
alias k="kubectl"
alias ksk="k -n kube-system"
alias ki="k -n ingress"
alias kis="k -n istio-system"
alias ks="k -n system"
alias ksh="k -n shared"
alias km="k -n monitoring"
alias kta="k -n team-admin"
alias ka="k --all-namespaces=true"
alias kaa="ka get po,rs,job,deploy,ds,statefulset,svc"
alias kap="ka get po"
alias kdel="k delete"
alias kcv="k config view"
alias kce="$EDITOR ~/.kube/config"
alias kcg="k config view | grep 'current-context:' | sed -n -e 's/^.*current-context: //p'"
alias kcu="k config use-context"
alias kp="k proxy &"
alias kp="killall kubectl"

img=otomi/tools:1.1.4
d --version &>/dev/null
hasDocker=$?
d ps &>/dev/null
dockerRunning=$?

drun() {
  # execute any kubectl command to refresh access token
  k version >/dev/null
  d run -it --rm -v $PWD:$PWD \
    -v ~/.kube/config:/home/app/.kube/config \
    -v /tmp:/tmp \
    -v ~/.aws:/home/app/.aws \
    -v ~/.azure:/home/app/.azure \
    -v ~/.config/gcloud:/home/app/.config/gcloud \
    -v ~/Library/Preferences/helm:/home/app/.config/helm \
    -e K8S_CONTEXT=$K8S_CONTEXT \
    -e CLOUD=$CLOUD \
    -e CLUSTER=$CLUSTER \
    -w $PWD $img $@
}

alias h="helm"
alias hk="h delete"
alias hf_="helmfile"

# if not has docker: ci
if [ $hasDocker -eq 0 ]; then
  echo "Found docker client, assuming developer context."
  if [ $dockerRunning -eq 0 ]; then
    echo "Found docker running, will use $img instead of local tooling"
    unalias h hf_ hk aw gc
    alias h="drun helm"
    alias hf_="drun helmfile"
    alias hk="drun helm delete"
    alias aw="drun aws"
    alias az="drun az"
    alias gc="drun gcloud"
  else
    echo "No docker daemon running. Please start and source aliases again."
  fi
fi

function kpk() { ps aux | grep "$@" | awk '{print $2}' | xargs kill; }
function kad() { k delete "$@" --all; }
function kdnp() {
  for ns in default kube-system system monitoring ingress shared; do
    kad networkpolicy -n $ns
  done
}
# force erase all namespaces
function kkns() {
  k proxy &
  k get ns | grep Terminating | awk '{print $1}' | xargs -n1 -- bash -c 'kubectl get ns "$0" -o json | jq "del(.spec.finalizers[0])" > "$0.json"; curl -k -H "Content-Type: application/json" -X PUT --data-binary @"$0.json" "http://127.0.0.1:8001/api/v1/namespaces/$0/finalize" '
  kk
}
# erase entire stack but keep nodes
function kkc() {
  k delete crd $(k get crd | egrep "cert-manager|istio|ory|coreos|knative|velero" | awk '{print $1}')
  hf_ -e ${CLOUD}-$CLUSTER destroy
  k delete ns --all
}

# export KUBE_CONFIG=~/.kube/config
# make a tmp copy from our local KUBE_CONFIG to target only our env
# tmpLocation="/tmp/otomi/kubecfg/$CLOUD"
# k8sConfig="$tmpLocation/$CLUSTER.yaml"
# mkdir -p $tmpLocation >/dev/null
# kcv >$k8sConfig
# export KUBE_CONFIG=$k8sConfig

# now switch
kcu $K8S_CONTEXT

# environment scoped:
function hf() { hf_ -e ${CLOUD}-$CLUSTER $@; }
# environment scoped, no deps, so faster:
function hfd() { hf $@ --skip-deps; }
# templates only without cruft:
function hft() { hfd --quiet $@ template | grep -vi skipping | grep -vi "helmfile-"; }

echo "Aliases loaded targeting CLOUD=$CLOUD and CLUSTER=$CLUSTER"
