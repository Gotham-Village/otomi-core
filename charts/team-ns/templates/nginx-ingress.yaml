{{- $ns := .Release.Namespace }}
{{- $v := .Values }}
{{- if or (eq $v.teamId "admin") ($v.cluster.isMultitenant) }}
{{- $authSvc := (eq $v.teamId "admin" | ternary "oauth2-proxy" (printf "oauth2-proxy-team-%s" $v.teamId)) }}
# split list of services into public and private to create separate ingresses:
# one for auth redirect and one passthrough
{{- $public := list }}
{{- $private := list }}
{{- range $s := $v.services }}
{{- if and (not $s.internal) (not $s.host) }}
{{- if hasKey $s "isPublic" }}
  {{- if $s.isPublic }}
  {{- $public = (append $public $s) }}
  {{- else }}
  {{- $private = (append $private $s) }}
  {{- end }}
{{- else }}
{{- $private = (append $private $s) }}
{{- end }}
{{- end }}
{{- end }}
# we always need an auth redirect ingress for private routes
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/auth-url: "http://oauth2-proxy{{ if ne $v.teamId "admin"}}-team-{{ $v.teamId }}{{ end }}.istio-system.svc.cluster.local/oauth2/auth"
    # the redirect part here is caught by the oauth2 ingress which will take care of the redirect
    nginx.ingress.kubernetes.io/auth-signin: "https://auth.{{ $v.domain }}/oauth2/start?rd=/oauth2/redirect/$http_host$escaped_request_uri"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      # set team header
      add_header Auth-Group "{{ $v.teamId }}";
      proxy_set_header Auth-Group "{{ $v.teamId }}";

      # split cookie if needed:
      auth_request_set $_oauth2_proxy_upstream_1 $upstream_cookie__oauth2_proxy_1;
      access_by_lua_block {
        if ngx.var._oauth2_proxy_upstream_1 ~= "" then
          ngx.header["Set-Cookie"] = "_oauth2_proxy_1=" .. ngx.var._oauth2_proxy_upstream_1 .. ngx.var.auth_cookie:match("(; .*)")
        end
      }
    {{- include "ingress-annotations" $v | nindent 4 }}
    ingress.kubernetes.io/ssl-redirect: {{ if $v.cluster.hasCloudLB }}"false"{{ else }}"true"{{ end }}
  labels: {{- include "chart-labels" . | nindent 4 }}
  name: nginx-ingress-team-{{ $v.teamId }}-private
  namespace: istio-system
spec:
  rules:
  {{- range $s := $private }}
  {{- if and (ne $s.name "auth") (not $s.internal) }}
  {{- $domain := (index $s "domain" | default (printf "%s.%s" $s.name $v.domain)) }}
  - host: {{ $domain }}
    http:
      paths:
      - path: /oauth2/userinfo
        backend:
          serviceName: {{ $authSvc }}
          servicePort: 80
      - backend:
          serviceName: istio-ingressgateway
          servicePort: 80
  {{- end }}
  {{- end }}
  {{- if not $v.cluster.hasCloudLB }} # tls was already terminated by cloud LB
  tls: {{- include "ingress-tls" $v | nindent 4 }}
  {{- end }}
{{- if ne (len $public) 0 }} # then we also have public routes without auth, so passthrough:
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    {{- include "ingress-annotations" $v | nindent 4 }}
    ingress.kubernetes.io/ssl-redirect: {{ if $v.cluster.hasCloudLB }}"false"{{ else }}"true"{{ end }}
  labels: {{- include "chart-labels" . | nindent 4 }}
  name: nginx-ingress-team-{{ $v.teamId }}-public
  namespace: istio-system
spec:
  rules:
  {{- range $s := $public }}
  {{- $domain := (index $s "domain" | default (printf "%s.%s" $s.name $v.domain)) }}
  - host: {{ $domain }}
    http:
      paths:
      - path: /oauth2/userinfo
        backend:
          serviceName: {{ $authSvc }}
          servicePort: 80
      - backend:
          serviceName: istio-ingressgateway
          servicePort: 80
  {{- end }}
  {{- if not $v.cluster.hasCloudLB }}
  tls: {{- include "ingress-tls" $v | nindent 4 }}
  {{- end }}
{{- end }}
{{- end }}
{{- if ne (len $v.proxies) 0 }}
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    {{- include "ingress-annotations" $v | nindent 4 }}
    nginx.ingress.kubernetes.io/ssl-redirect: {{ if $v.cluster.hasCloudLB }}"false"{{ else }}"true"{{ end }}
    nginx.ingress.kubernetes.io/upstream-vhost: $1.{{ $v.domain }}
    nginx.ingress.kubernetes.io/rewrite-target: $2
  labels: {{- include "chart-labels" . | nindent 4 }}
  name: nginx-ingress-team-{{ $v.teamId }}-proxy
  namespace: istio-system
spec:
  rules:
  {{ range $p := $v.proxies }}
  - host: {{ printf "proxy.%s" $v.domain }}
    http:
      paths:
      - backend:
          serviceName: istio-ingressgateway
          servicePort: 80
        path: /({{ $p.name }})({{ $p.path }})
  {{- end }}
  {{- if not $v.cluster.hasCloudLB }}
  tls:
    - hosts:
        - {{ printf "proxy.%s" $v.domain }}
      secretName: cert-team-{{ $v.teamId }}
  {{- end }}
{{- end }}
